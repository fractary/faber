# SPEC: FABER Plan Generation Missing Resolved Workflow Prompts

## Problem Statement

The `faber plan` CLI (v1.3.2) generates workflow execution plans that are **missing the resolved `prompt` fields** from the workflow definition chain. This means the downstream workflow runner (`/fractary-faber:workflow-run`) receives plans without the executable slash commands that drive step execution, making it impossible for the runner to invoke the correct skills/agents for each step.

## Observed Behavior

**Plan generated by CLI** (issue #153, `dataset-create` workflow):
```json
{
  "phases": [{
    "phase": "build",
    "steps": [
      {
        "action": "build-engineer",
        "details": "Implement AWS Glue ETL job Python script..."
      },
      {
        "action": "build-engineer-validate",
        "details": "Validate loader code, configuration files..."
      },
      {
        "action": "build-deploy-plan-test",
        "details": "Create/update Terraform configuration..."
      }
    ]
  }]
}
```

Steps only have `action` (step ID) and `details` (freeform text generated by Claude). No `prompt` field.

## Expected Behavior

The plan should include the resolved slash command `prompt` from the workflow definition chain:

```json
{
  "phases": [{
    "phase": "build",
    "steps": [
      {
        "action": "build-engineer",
        "details": "Implement AWS Glue ETL job Python script...",
        "prompt": "/fractary-faber-code:engineer --work-id {work_id}",
        "source": "fractary-faber-code:default",
        "result_handling": {
          "on_failure": "/fractary-faber:workflow-debug --work-id {work_id} --run-id {run_id} --problem \"{error}\" --auto-fix"
        }
      },
      {
        "action": "build-engineer-validate",
        "details": "Validate loader code, configuration files...",
        "prompt": "/fractary-faber-code:engineer-validate --work-id {work_id}",
        "source": "fractary-faber-code:default",
        "result_handling": {
          "on_failure": "/fractary-faber:workflow-debug --work-id {work_id} --run-id {run_id} --problem \"{error}\" --auto-fix"
        }
      },
      {
        "action": "build-deploy-plan-test",
        "details": "Create/update Terraform configuration...",
        "prompt": "/faber-cloud:deploy-plan --work-id {work_id} --env test",
        "source": "fractary-faber-code:default"
      }
    ]
  }]
}
```

## Impact

- **Workflow runner cannot execute steps properly** - Without `prompt` fields, the runner doesn't know which skill/agent to invoke
- **Runner forced to improvise or fail** - The runner either guesses what to do (wrong) or stops (blocking)
- **Context overlays lost** - The workflow definition's context overlays (global, phase, step) are not included in the plan, so the runner can't inject the correct context when invoking steps
- **Result handling lost** - Step-level `result_handling` config (on_failure recovery commands) is not in the plan
- **Autonomy configuration lost** - The resolved `autonomy` settings are not included

## Root Cause Analysis

### The Plan Generation Pipeline

```
faber plan --work-id 153
  |
  +- 1. WorkflowResolver.resolveWorkflow("dataset-create")
  |     +- Resolves: dataset-create -> faber-code:default -> faber:core
  |     +- Merges all steps with id, name, prompt, result_handling, source
  |     +- Returns: ResolvedWorkflow (complete, with all prompt fields)
  |
  +- 2. constructPlanningPrompt(input, resolvedWorkflow)
  |     +- Sends FULL resolved workflow to Claude as context
  |     +- BUT: Output format schema only asks for action + details
  |     +- Claude generates simplified plan without prompts
  |
  +- 3. generatePlan() assembles final plan
        +- Takes Claude's response (action + details only)
        +- Adds metadata (plan_id, issue, branch, worktree, workflow name)
        +- Does NOT merge resolved workflow prompts back in
```

### Specific Code Locations

**File**: `cli/src/lib/anthropic-client.ts`

**Line 117** - Workflow resolved correctly:
```typescript
const workflowConfig = await resolver.resolveWorkflow(input.workflow);
// workflowConfig.phases.build.steps[0] = {
//   id: "build-engineer",
//   prompt: "/fractary-faber-code:engineer --work-id {work_id}",
//   name: "Engineer Solution",
//   source: "fractary-faber-code:default",
//   result_handling: { on_failure: "..." }
// }
```

**Lines 197-224** - Output format doesn't include prompt:
```typescript
// The prompt template asks Claude to produce:
// { "action": "specific action", "details": "additional context" }
// Missing: prompt, source, result_handling, guards
```

**Lines 147-165** - No post-processing to merge prompts:
```typescript
const planJson = this.extractJsonFromResponse(content.text);
// planJson only has action + details from Claude
// resolvedWorkflow with prompts is available but never merged in
const plan: WorkflowPlan = {
  ...planJson,
  plan_id: planId,
  // ... metadata only, no prompt merging
};
```

### Plan Schema Already Supports It

The plan schema (`cli/schemas/plan.schema.json`, lines 152-177) already defines `prompt` and `command` as optional step fields:

```json
{
  "step": {
    "properties": {
      "action": { "type": "string" },
      "details": { "type": "string" },
      "command": { "type": ["string", "null"] },
      "prompt": { "type": "string" }
    }
  }
}
```

These fields just never get populated.

## Proposed Solution

### Approach: Post-Process Plan to Merge Resolved Prompts

After Claude generates the plan (step 2 above) and before returning it (step 3), add a post-processing step that matches each plan step's `action` to the resolved workflow step's `id` and merges in the `prompt`, `source`, `result_handling`, and `guards` fields.

This approach is preferred over changing the Claude prompt because:
1. The resolved workflow is the **source of truth** for prompts - no risk of Claude hallucinating commands
2. It's deterministic - same workflow always produces same prompts
3. It preserves the current prompt design where Claude adds value through `details` contextualizing

### Implementation

**1. Add `mergeWorkflowPrompts()` method** to `AnthropicClient`:

```typescript
/**
 * Merge resolved workflow prompt fields into plan steps.
 *
 * The planning prompt asks Claude for a simplified format (action + details),
 * but the workflow runner needs the executable prompt commands. This method
 * matches each plan step's `action` to the resolved workflow step's `id` and
 * copies over the `prompt`, `source`, `result_handling`, and `guards` fields.
 */
private mergeWorkflowPrompts(planJson: any, workflowConfig: ResolvedWorkflow): void {
  // Build a lookup map: step.id -> WorkflowStep
  const stepMap = new Map<string, WorkflowStep>();
  for (const [phaseName, phase] of Object.entries(workflowConfig.phases)) {
    for (const step of (phase as ResolvedPhase).steps) {
      stepMap.set(step.id, step);
    }
  }

  // Merge prompts into plan steps
  for (const phase of planJson.phases || []) {
    for (const step of phase.steps || []) {
      const workflowStep = stepMap.get(step.action);
      if (workflowStep) {
        step.prompt = workflowStep.prompt;
        if (workflowStep.source) {
          step.source = workflowStep.source;
        }
        if (workflowStep.result_handling) {
          step.result_handling = workflowStep.result_handling;
        }
        if (workflowStep.guards) {
          step.guards = workflowStep.guards;
        }
      }
    }
  }
}
```

**2. Call it in `generatePlan()`** after extracting Claude's response (after line 147):

```typescript
const planJson = this.extractJsonFromResponse(content.text);

// Merge resolved workflow prompts into plan steps
this.mergeWorkflowPrompts(planJson, workflowConfig);
```

**3. Include context overlays and autonomy** in the plan metadata (around line 151):

```typescript
const plan: WorkflowPlan = {
  ...planJson,
  plan_id: planId,
  // ... existing metadata ...
  workflow: input.workflow,
  // Add resolved workflow metadata
  inheritance_chain: workflowConfig.inheritance_chain,
  autonomy: workflowConfig.autonomy?.level || 'guarded',
  context: workflowConfig.context || null,
};
```

### Files to Modify

| File | Change |
|------|--------|
| `cli/src/lib/anthropic-client.ts` | Add `mergeWorkflowPrompts()`, call in `generatePlan()`, include context/autonomy |
| `cli/schemas/plan.schema.json` | Add `source`, `result_handling`, `guards` to step schema; add `inheritance_chain`, `context` to root |

## Verification

1. Build CLI: `npm run build`
2. Regenerate a plan: `faber plan --work-id <test-issue> --force`
3. Inspect plan.json:
   - Every step whose `action` matches a workflow step ID should have a `prompt` field
   - Steps from core.json (e.g., `core-fetch-issue`) should have `prompt: "/fractary-work:issue-fetch --work-id {work_id}"`
   - Steps from faber-code:default (e.g., `build-engineer`) should have `prompt: "/fractary-faber-code:engineer --work-id {work_id}"`
   - Steps added by the project workflow that have prompts (e.g., evaluate publish steps) should also have their prompts
   - `result_handling` should be present where defined in workflow definitions
4. Run workflow: `/fractary-faber:workflow-run <work-id>` - runner should find and execute prompts

## Discovery Context

Found during workflow execution of etl.corthion.ai issue #153 (IPEDS EFFY 2024). The workflow runner could not determine which skills/agents to invoke because the plan only had `action` + `details`, forcing it to either look up the workflow definitions at runtime (not implemented) or improvise (wrong behavior).

### Workflow Chain for Reference

```
faber@fractary-faber:core
+-- auto-reload-context  ->  /fractary-faber:session-load
+-- core-fetch-issue     ->  /fractary-work:issue-fetch --work-id {work_id}
+-- frame-commit-and-push -> /fractary-repo:commit-push --work-id {work_id}
+-- build-create-pr      ->  /fractary-repo:commit-push-pr --work-id {work_id}
+-- ... (issue comments, codex sync, pr merge, etc.)

faber-code@fractary-faber-code:default (extends core)
+-- frame-research       ->  /fractary-faber-code:research --work-id {work_id}
+-- frame-research-validate -> /fractary-faber-code:research-validate --work-id {work_id}
+-- architect-inspect    ->  /fractary-faber-code:inspect --work-id {work_id}
+-- architect-design     ->  /fractary-faber-code:architect --work-id {work_id}
+-- architect-design-validate -> /fractary-faber-code:architect-validate --work-id {work_id}
+-- build-engineer       ->  /fractary-faber-code:engineer --work-id {work_id}
+-- build-engineer-validate -> /fractary-faber-code:engineer-validate --work-id {work_id}
+-- build-deploy-plan-test -> /faber-cloud:deploy-plan --work-id {work_id} --env test
+-- build-deploy-plan-prod -> /faber-cloud:deploy-plan --work-id {work_id} --env prod
+-- build-engineer-document -> /fractary-docs:write --work-id {work_id} --context "..."
+-- evaluate-deploy-apply-test -> /faber-cloud:deploy-apply --work-id {work_id} --env test
+-- evaluate-deploy-validate-test -> /faber-cloud:validate --work-id {work_id} --env test
+-- ... (release deploy, etc.)

dataset-create (extends faber-code:default) -- project level
+-- Context overlays for all inherited steps (dataset-specific instructions)
+-- evaluate-dataset-publish-test -> /fractary-faber-cloud:execute --work-id {work_id} --handler aws-glue --env test ...
+-- evaluate-dataset-publish-validate-test -> /dataset-publish-validate --work-id {work_id} --env test ...
+-- release-dataset-publish-prod -> /fractary-faber-cloud:execute --work-id {work_id} --handler aws-glue --env prod ...
+-- release-dataset-publish-validate-prod -> /dataset-publish-validate --work-id {work_id} --env prod ...
```
